
#include "element_GFX.h"

uint8_t framebuffer[ELEMENT_LEDS * 3] = { 0 };

// autogenerated byte-reversed gamma table
// parameters: gamma = 1.7
const uint16_t gamma_table[] = {
	0x0000, 0x0500, 0x1100, 0x2200, 0x3800, 0x5200, 0x7000, 0x9100, 0xB600, 0xDF00, 
	0x0A01, 0x3901, 0x6B01, 0xA001, 0xD801, 0x1302, 0x5002, 0x9002, 0xD302, 0x1903, 
	0x6103, 0xAC03, 0xF903, 0x4904, 0x9C04, 0xF004, 0x4705, 0xA105, 0xFD05, 0x5B06, 
	0xBC06, 0x1E07, 0x8407, 0xEB07, 0x5408, 0xC008, 0x2E09, 0x9E09, 0x100A, 0x850A, 
	0xFB0A, 0x730B, 0xEE0B, 0x6B0C, 0xE90C, 0x6A0D, 0xED0D, 0x720E, 0xF80E, 0x810F, 
	0x0C10, 0x9810, 0x2711, 0xB711, 0x4A12, 0xDE12, 0x7413, 0x0D14, 0xA714, 0x4215, 
	0xE015, 0x8016, 0x2117, 0xC517, 0x6A18, 0x1119, 0xB919, 0x641A, 0x101B, 0xBE1B, 
	0x6E1C, 0x201D, 0xD31D, 0x881E, 0x3F1F, 0xF81F, 0xB220, 0x6E21, 0x2C22, 0xEC22, 
	0xAD23, 0x7024, 0x3425, 0xFB25, 0xC326, 0x8C27, 0x5828, 0x2429, 0xF329, 0xC32A, 
	0x952B, 0x692C, 0x3E2D, 0x152E, 0xED2E, 0xC72F, 0xA330, 0x8031, 0x5F32, 0x4033, 
	0x2234, 0x0635, 0xEB35, 0xD236, 0xBA37, 0xA438, 0x9039, 0x7D3A, 0x6B3B, 0x5C3C, 
	0x4D3D, 0x413E, 0x363F, 0x2C40, 0x2441, 0x1D42, 0x1843, 0x1544, 0x1345, 0x1246, 
	0x1347, 0x1648, 0x1A49, 0x1F4A, 0x264B, 0x2F4C, 0x394D, 0x444E, 0x514F, 0x6050, 
	0x6F51, 0x8152, 0x9453, 0xA854, 0xBE55, 0xD556, 0xED57, 0x0859, 0x235A, 0x405B, 
	0x5E5C, 0x7E5D, 0xA05E, 0xC25F, 0xE660, 0x0C62, 0x3363, 0x5B64, 0x8565, 0xB066, 
	0xDD67, 0x0B69, 0x3B6A, 0x6B6B, 0x9E6C, 0xD16D, 0x066F, 0x3D70, 0x7571, 0xAE72, 
	0xE873, 0x2475, 0x6276, 0xA077, 0xE078, 0x227A, 0x657B, 0xA97C, 0xEE7D, 0x357F, 
	0x7E80, 0xC781, 0x1283, 0x5F84, 0xAC85, 0xFB86, 0x4C88, 0x9D89, 0xF08A, 0x458C, 
	0x9A8D, 0xF18E, 0x4A90, 0xA391, 0xFE92, 0x5B94, 0xB895, 0x1797, 0x7898, 0xD999, 
	0x3C9B, 0xA09C, 0x069E, 0x6D9F, 0xD5A0, 0x3EA2, 0xA9A3, 0x15A5, 0x82A6, 0xF1A7, 
	0x61A9, 0xD2AA, 0x45AC, 0xB9AD, 0x2EAF, 0xA4B0, 0x1CB2, 0x94B3, 0x0FB5, 0x8AB6, 
	0x07B8, 0x85B9, 0x04BB, 0x85BC, 0x07BE, 0x8ABF, 0x0EC1, 0x94C2, 0x1AC4, 0xA3C5, 
	0x2CC7, 0xB7C8, 0x42CA, 0xD0CB, 0x5ECD, 0xEDCE, 0x7ED0, 0x10D2, 0xA4D3, 0x38D5, 
	0xCED6, 0x65D8, 0xFED9, 0x97DB, 0x32DD, 0xCEDE, 0x6BE0, 0x0AE2, 0xA9E3, 0x4AE5, 
	0xECE6, 0x90E8, 0x34EA, 0xDAEB, 0x81ED, 0x29EF, 0xD3F0, 0x7DF2, 0x29F4, 0xD6F5, 
	0x85F7, 0x34F9, 0xE5FA, 0x97FC, 0x4AFE, 0xFFFF
};

void Element_GFX::constructor()
{
  // set the pin for output:
  pinMode(ELEMENT_LATCH, OUTPUT);
  digitalWrite(ELEMENT_LATCH, LOW);
  
  Adafruit_GFX::constructor(ELEMENT_W, ELEMENT_H);
}

void Element_GFX::transfer(uint8_t data)
{
  SPDR = data;
  while(!(SPSR & (1<<SPIF)));
}

void Element_GFX::drawPixelNum(int16_t num, uint32_t color)
{
  int idx;
  idx = 3 * num;
  
  framebuffer[idx + 0] = (color & 0xFF0000) >> 16;
  framebuffer[idx + 1] = (color & 0x00FF00) >> 8;
  framebuffer[idx + 2] = (color & 0x0000FF) >> 0;
}
void Element_GFX::drawPixel(int16_t x, int16_t y, uint32_t color)
{
  if (x < 0 || x >= _width || y < 0 || y >= _height)
    return;
    
  int idx, i, j;
  
  switch (rotation)
  {
    case 0:
      i = (x);
      j = (y);
      break;
    case 1:
      i = (WIDTH - 1 - y);
      j = (x);
      break;
    case 2:
      i = (WIDTH - 1 - x);
      j = (HEIGHT - 1 - y);
      break;
    case 3:
      i = (y);
      j = (HEIGHT - 1 - x);
      break;
  }
  
  idx = 3 * ((j) * WIDTH + (i));
  
  framebuffer[idx + 0] = (color & 0xFF0000) >> 16;
  framebuffer[idx + 1] = (color & 0x00FF00) >> 8;
  framebuffer[idx + 2] = (color & 0x0000FF) >> 0;
}


void Element_GFX::invertDisplay(boolean i)
{
  for (int i = 0; i < ELEMENT_LEDS * 3; ++i)
    framebuffer[i] = 256 - framebuffer[i];
}

void Element_GFX::sendFrame()
{
  int pixnum = 0;
  int idx = 0;
  byte r, g, b;
  uint16_t data[3];
  
  // generate and write out data
  while (pixnum < ELEMENT_LEDS)
  {
    idx = 3 * ((ELEMENT_LEDS - 1) - pixnum);
    
    data[0] = gamma_table[framebuffer[idx + 0]];
    data[1] = gamma_table[framebuffer[idx + 1]];
    data[2] = gamma_table[framebuffer[idx + 2]];

    // sending out data on SPI - Teensy
    // one transfer for each byte
    transfer(((uint8_t*)data)[0]);
    transfer(((uint8_t*)data)[1]);
    transfer(((uint8_t*)data)[2]);
    transfer(((uint8_t*)data)[3]);
    transfer(((uint8_t*)data)[4]);
    transfer(((uint8_t*)data)[5]);    

    ++pixnum;
   }
   
   // toggle latch pin
   delay(1);
   digitalWrite(ELEMENT_LATCH, HIGH);
   delay(1);
   digitalWrite(ELEMENT_LATCH, LOW);
}

uint32_t make_color(uint8_t r, uint8_t g, uint8_t b)
{
  return ((uint32_t)r << 16) | ((uint32_t)g << 8) | ((uint32_t)b);
}

// courtesy http://www.adafruit.com/blog/2012/03/14/constant-brightness-hsb-to-rgb-algorithm/
uint32_t hsv_to_rgb(uint16_t hue, uint8_t sat, uint8_t value) // hue is [0 .. 767]
{
  uint8_t temp[5], n = (hue >> 8);// % 3; // mod 3 only necessary if input goes higher than 767
  temp[0] = temp[3] = (uint8_t)((                                       (sat ^ 255)  * value) / 255);
  temp[1] = temp[4] = (uint8_t)((((( (hue & 255)        * sat) / 255) + (sat ^ 255)) * value) / 255);
  temp[2] =           (uint8_t)(((((((hue & 255) ^ 255) * sat) / 255) + (sat ^ 255)) * value) / 255);
  
  return make_color(temp[n + 2], temp[n + 1], temp[n + 0]);
}

